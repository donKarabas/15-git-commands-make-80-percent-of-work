# Начинаем работать с GIT и удаленной репой

Чтоб работать с гит в конкретном проекте, нам нужно инициализировать гит для этого проекта, это делается один раз, как правило в начале проекта.

# Инициализируем GIT:

При инициализации гит создает скрытую директорию где хранит историю вашего проекта. Для этого в корне проекта выполним команду:
```
git init
```
В нашем проекте появилась новая директория .git, посмотрим на нее:
```
ls -la
```

# Зафиксируем изменения:

Итак, мы создали файл README.md, потом проинициализировали GIT и теперь я хочу чтоб  данные изменения стали доступны другим разработчикам. Для этого мне нужно отправить 'посылочку' с моими изменениями на удаленный сервер (origin). Давайте создадим 'посылочку'.

Для начала посмотрим что происходит в нашем репозитории:
```
git status
```
Данная команда показывает актуальное состояние репозитория. И сейчас она нам говорит что есть файл с изменениями которые не в индексе, подсвечивая его красным.

Но прежде чем добавлять файл в индекс, сделаем кое что другое, добавим в корне проекта файл .gitignore:

~/Projects/front-end-pro/.gitignore
```
# Web Storm directory
/.idea

# Visual Studio directory
/.vs

# Директория с модулями nodejs
/node_modules
```
.gitignore - файл с указаниями какие файлы и директории не должны попасть в индекс GIT. Например рабочие файлы IDE для нашего проекта, смысла шарить их с другими разработчиками нет, поэтому игнорируем их.

Полный список директорий для Visual Studio для .gitignore можно найти вот тут: See https://github.com/github/gitignore/blob/main/VisualStudio.gitignore

Все теперь можно добавлять наш файл в индекс гита, делается это с помощью команды:
```
git add .
```
Данная команда добавляет все файлы проекта в индекс (кроме тех которые указаны в .gitignore). т.е. мы как будто говорим: 'Гит, добавь в индекс все изменения которые произошли в нашем проекте!'.

Обратите внимание точка означает 'добавь в индекс все файлы которые были изменены'. Точку проще написать чем перечислять названия всех файлов через пробел, будем ее использовать всегда.

Если нужно добавить в индекс прицельно один или несколько файлов, перечисленных через пробел, то можно написать вот так тогда в файле .gitignore нет необходимости:
```
git add README.md
```

Посмотрим какое теперь состояние у нашего репозитория:
```
git status
```
Все, наш файл зелененький - теперь он в индексе.

Зафиксируем изменения:
```
git commit -m "Initial commit"
```
Данная команда создает новый коммит - снимок изменений нашего проекта. Это как комар в янтаре. Вы не можете с ним ничего сделать но можете на него посмотреть с разных сторон и сравнить с другим комаром например :)

Все, посылочка сформирована, давайте посмотри на нее повнимательнее:
```
git log
```
Данная команда показывает историю коммитов (снимков изменений). Здесь есть дата когда были сделаны изменения, имя и почта автора чтоб можно было потом найти и заставить съесть этого комара в случае чего :). И самое важное это уникальный идентификатор коммита который нельзя поменять. Он нужен что бы ваш коммит не потерялся среди других коммитов т.е. снимков изменений т.е. комаров.

Не подумайте что я бывший энтомолог, нет, по моему просто пример хороший.

(!) Тут важно отметить что когда вы создаете первый коммит в проекте то гит автоматически создает для вас новую ветку которая называется master или main, сейчас рекомендуется использовать название main для основной ветки по причинам связанным с историей рабства.

**Ветка (branch) в гите** - это последовательность коммитов. Мы поработаем с ними чуть позже.




## Отправим наши изменения:

Сейчас все наши изменения (коммиты) хранятся только локально и чтобы они стали доступны другим разработчикам мы должны отправить их на удаленный репозиторий откуда другие разработчики смогут их себе скачать. Выполним:
```
git push
```
Это команда отправляет наши изменения на удаленный репозиторий. Но первый раз она не сработает потому что мы не указали адрес куда отправлять коммиты, оно и не странно потому что адреса пока нет.

Создадим новый чистый репозиторий с названием таким-же как и директория проекта в https://github.com/new и скопируем новый адрес.

Теперь мы можем привязать локальный проект к удаленному репозиторию:
```
git remote add origin git@github.com:volodymyr-kryvoshapov/front-end-pro.git
```

Выполним снова команду
```
git push
```
И мы видим что гит все еще ничего не отправил а выдал нам новое сообщение:
```
fatal: The current branch main has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin main
```
Перевожу на язык понятный для простых смертных: 'да, я теперь знаю адрес репозитория куда отправлять изменения, и я вижу что ты свои изменения хранишь в локальной ветке main но я не в курсе в какую удаленную ветку ты хочешь отправить новые изменения. Может быть создать на удаленном сервере ветку с таким же названием как и на локальном сервере и отправить изменения в нее?' Мы говори да, сделай это и выполняем команду которую предлагает гит.
```
git push --set-upstream origin main
```
Гит говорит нам что локальная ветка 'main' настроена на отслеживание удаленной ветки 'main' из 'origin' (удаленного репозитория). Настройка связи между локальной и удаленной ветками делается один раз для каждой ветки при попытке пуша.

Переходим на наш репозиторий в github, обновляем страницу и видим нашу ветку, наш коммит и наш файл.