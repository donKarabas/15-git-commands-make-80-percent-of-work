# Реализуем новую фичу 'calc' + Pull Request (PR):

Вместо двух команд: `git branch calc && git checkout calc` мы будем использовать совмещенную запись, которая создает ветку и сразу переключается на нее:

```
git checkout -b "calc"
```

Реализуем фичу калькулятор, добавим два файла с кодом:

~/Projects/front-end-pro/calc/index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script src="index.js" async></script>
</head>
<body>
  <h1>Описание будет добавлено позже!</h1>
</body>
</html>
```

~/Projects/front-end-pro/calc/index.js

```html
console.log(calc(8, 9));


function calc(num, num2) {
  return num + num2;
}
```

Добавим изменения в индекс:

```
git add .
```

Закоммитим:

```
git commit -m "Calculator feature"
```

Отлично, закомитили.

А теперь не будем переключатся в `main` и затягивать `calc` в `main`, а сделаем кое-что интересное, мы добавим промежуточное действие pull request.

Pull request (PR) - это запрос разрешения на добавление изменений в какую-то ветку. Создавая PR вы говорите другим о намерении добавить изменения в какую-то ветку, и другие разработчикам теперь могут проверить ваш код на наличие ошибок, обсудить их, и если все ок, затянуть изменения в указанную ветку. Т.е. это промежуточный этап между переключением на ветку и затягиванием (мерджем) изменений из другой ветки.

PR используется в open-source проектах и компаниях для проверки качества кода (code review) перед тем как эти изменения будут 'затянуты' (именно поэтому и пулл реквест) в основную ветку. Под 'затянуть изменения' имеется ввиду мердж изменений `git merge branch_name`.

PR это фича не GIT а площадок которые работают на основе GIT. В GIT нет такой команды как pull request.

Для этого запушим нашу ветку в удаленный репозиторий:

```
git push
```

Перейдем в Git Hub, создадим PR и отправим его на ревью:

Наш PR не прошел ревью, исправим его, добавим аннотацию для функции:

```javascript
console.log(calc(8, 9));

/**
 * Function adds two numbers
 *
 * @param {number} num
 * @param {number} num2
 * @returns {number}
 */
function calc(num, num2) {
  return num + num2;
}
```

Добавим изменения в индекс:

```
git add .
```

Закоммитим:

```
git commit -m "Added calc() f. description"
```

(!) Обратите внимание что в сообщении для коммита мы пишем то что сделали.

Закомитили, теперь снова пушим в удаленный репозиторий:

```
git push
```

Снова скидываем ссылку на ревью. Другие разработчики подтверждают что теперь все ок.

И теперь мы мерджим изменения в `main` через интерфейс GitHub. Давайте посмотрим что изменения из нашей ветки действительно попали в `main`, перейдем на https://github.com/volodymyr-kryvoshapov/front-end-pro. Да действительно теперь наша фича `calc` в ветке `main`.

Вот что мы сделали (смотрим второй сиреневый круг):
<img src="../git-branch.png" width="700">

Следите за руками:
- Есть моя ветка в которой я запилил фичу и главная ветка `main` (`master`).
- Я хочу чтоб мои изменения из `calc` попали (затянули, были смерджены) в `main`.
- Я создаю запрос на добавление изменений (PULL Request) из `calc` -> `main`.
- Скидываю ссылку на PR другим разработчикам для проверки.
- Другие разработчики смотрят PR, этот процесс называется code review, отписывают комментарии если нужно что-то исправить.
- После исправлений делается новый `git commit` и `git push` в ветку `calc`.
- Код проверяется другими разработчиками снова и если все ок дается добро на мердж PR.
- PR мерджится в `main`.
- Ветка фичи `calc` более не нужна и может быть удалена.

Давайте удалим ее. Так как мы на ветке `calc` то переключимся в `main` потому что мы не можем удалить ту ветку на которой находимся:

```
git checkout main
```

Посмотрим на ветки перед удалением:

```
git branch
```

Удалим ветку `calc`

```
git branch -d calc
```

Посмотрим на ветки еще раз:

```
git branch
```

Отлично ветки больше нет. Удалять ветки не обязательно просто когда их станивится много то среди большого списка сложно найти свои актуальные ветки.
