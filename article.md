## 15 основных команд составляют 80% работы с Git.

Я бы хотел что бы мне объяснили GIT именно так в начале моей карьеры.





## Что в видео?

- Обретение смыслов, что это вообще GIT и зачем?.
- Требования для работы с GIT.
- Настройка SSH доступа в GitHub.
- Как правильно организовать ваши проекты.
- Создание репозитория в GitHub.
- И как говорится 'самое мясо':
  - Непосредственно работа с GIT и удаленной репой
  - ~~Съедим~~ исправим жука и создадим две фичи
  - Научимся решать конфликты в файлах при мердже
- Файлы .git и .gitignore
- Дополнительные полезные команды.




## Обретение смыслов:

- **GIT** - Распределенная система версий придуманая человеком легендой Linus Torvalds который сначала придумал линукс, которым теперь все пользуются, большая часть серверов работает именно на линуксе, а потом GIT для разработки этого самого линукса. Он придумал GIT для того чтобы над проектом могло работать большое количество людей не мешая при этом друг другу. Потому что когда над одним проектом работает 10 или 100 или 1000 человек и каждый разрабатывает какую-то свою часть то потом все эти изменения как-то нужно совмещать. Представьте что вы разрабатываете какую-то новую фичу для этого вы себе локально скопировали актуальный проекта с удаленного сервера. Когда вы закончили разработку своей фичи то ваш локальный проект очень сильно отличается от проекта на удаленном сервере, потому что другие разработчики добавили туда кучу своих изменений. И теперь вопрос в задачнике как вам совместить вашу работу с изменениями которые сделали другие разработчики? Именно эту задачу и решает GIT.
- **Распределенная система** - это когда есть какой-то удаленный сервер (т.е. не ваш локальный компьютер), обычно его называют origin например GitHub, GitLab, Bitbuket или свой личный сервер, на котором содержится репозиторий. И локальная версия этого проекта, копия (клон), у каждого разработчика. Изменения делаются локально и отправляются на удаленный сервер после чего становятся доступны другим разработчикам. Удаленный репозиторий - это как перевалочный пункт. Через который изменений должны пройти прежде чем станут доступны другим разработчикам.
<img src="./git-distributed-system.png" width="700">
- **Репозиторий Git** — это хранилище файлов проекта.
- **Cистема версий** - это программа для удивительных путешествий во времени позволяющая посмотреть как ваш проект выглядел год назад. Классический пример это хранение версий всего вашего проекта в директориях под названием проект-версия-1, проект-версия-2 и т.д. Но представьте что ваш проект занимает 1 Гб и при изменении 1 файла пришлось бы копировать 1 Гб в новую директорию. Система версий как-раз следит за тем чтоб этого не происходило и копировались и сохранялись в истории только те файлы или части файлов которые были изменены.


## Требования:

1. **Понимание как открыть терминал в Mac или Linux или Windows** (PowerShell или Git Bash).
2. **Установленный GIT.** Что бы проверить установлен ли GIT, вводим команду в терминале:
    ```
    git --version
    ```
    Должно вывести что-то типа:
    ```
    git version 2.24.3 (Apple Git-128)
    ```
    Если не вывело то установи GIT перейдя по ссылке: https://git-scm.com/book/en/v2/Getting-Started-Installing-Git
    
    После установки, если вы этого еще не делали, нужно настроить данные которыми будем подписывать все комиты (это делается один раз). Выполните в консоли:
    ```
    git config --global user.name "Harry Potter"
    git config --global user.email your_email@example.com
    ```
3. **Аккаунт в https://github.com**. Подразумевается, что он у вас уже есть, если нет то зарегистрируйтесь.
4. **Настроенный SSH доступ в аккаунт GitHub.** Что бы проверить доступ, вводим команду в терминале:
    ```
    ssh -T git@github.com
    ``` 
   Если доступ установлен то выдаст следующее:
    ```
    > Hi username! You've successfully authenticated, but GitHub does not 
    > provide shell access.
    ```
   Если нет то переходим к следующему шагу.




## Настройка SSH доступа в аккаунт GitHub

- SSH (Secure Shell Protocol) - это специальный криптографический протокол который устанавливает безопасное соединение, между вашим компьютером и каким-то другим компьютером в нашем случае github сервером, для обмена данными. При этом логин и пароль каждый раз вводить не нужно, соединение устанавливается на основе специально сгенерированного публичного и приватного ключа. С помощью SSH можно с одного линукса залогиниться на другой линукс сервер, а также с виндовса на другие линукс сервера. Такое соединение намного удобнее и безопаснее чем использование паролей, а также экономит время.
- Для того чтобы SSH аутентификация заработала вам нужно локально на вашей машине сгенерировать публичный и приватный ключи. Приватный ключ живет только на вашем компьютере и вы его никому не передаете. Публичный ключ живет на сервере к которому вы хотите получить SSH доступ.
- Настроим SSH доступ. Для начала проверим нет ли уже сгенерированного ключа, для этого в терминале вводим:
    ```
    ls -al ~/.ssh
    ```
  Знак ~ (тильда) означает домашнюю директорию, т.е. файлы которые относятся конкретно к вашему пользователю на данной машине.

    Должен быть файл с расширением .pub, если есть то генерацию нового ключа пропускаем.
    Если нет то генерируем новый ключ, для этого вводим команду в терминале и просто везде нажимаем enter несколько раз соглашаясь со всеми дефолтными значениями:
    ```
    ssh-keygen -t ed25519 -C "your_email@example.com"
    ```
    Проверяем файлы ключей:
    ```
    ls -al ~/.ssh
    ```
    Мы видим два файла это публичный и приватный ключи. Нас интересует содержимое файла публичного ключа. Для это воспользуемся командой:
    ```
    cat ~/.ssh/id_ed25519.pub
    ```
    Теперь нам нужно добавить ключ в GitHub, для этого копируем его в буфер, переходим в https://github.com/settings/keys и добавляем новый ключ.
    
    Проверяем доступ:
    ```
    ssh -T git@github.com
    ```
    Доступ установлен, отлично. Приготовления закончили, переходим к самому интересному.




## Создадим проект

Первый вопрос который возникает это где его создать и вообще где правильно хранить проекты на своей локальной машине чтоб было удобно? Файлы проектов нужно хранить:

Linux and Mac:
```
mkdir ~/projects
cd ~/projects
```
Можете назвать директорию с большой буквы если аналогичные диретории на этом уровне называются с большой буквы.

Windows PowerShell:
```
mkdir $env:USERPROFILE\projects
cd $env:USERPROFILE\projects
```
Windows CMD:
```
mkdir %USERPROFILE%\projects
cd %USERPROFILE%\projects
```

Создадим директорию проекта с любым названием, например: 'front-end-pro' или 'home-works' или 'git-experiments' и перейдем в нее:
```
mkdir ~/Projects/front-end-pro
cd ~/Projects/front-end-pro
```
Все заготовка для нашего проекта готова.

Именно так и нужно создавать новый проект. 




## Добавим файл в наш проект:

~/Projects/front-end-pro/README.md
```
Здесь будет описание нашего проекта
```




## Инициализируем GIT:

При инициализации гит создает скрытую директорию где хранит историю вашего проекта. Это делается один раз, как правило в начале проекта. Для этого в корне проекта выполним команду:
```
git init
```
В нашем проекте появилась новая директория .git, посмотрим на нее:
```
ls -la
```




## Зафиксируем изменения:

Итак, мы создали файл README.md, потом проинициализировали GIT и теперь я хочу чтоб  данные изменения стали доступны другим разработчикам. Для этого мне нужно отправить посылочку с моими изменениями на удаленный сервер (origin). Давайте создадим посылочку.

Для начала посмотрим что происходит в нашем репозитории:
```
git status
```
Данная команда показывает актуальное состояние репозитория. И сейчас она нам говорит что есть файл с изменениями которые не в индексе, подсвечивая его красным.

Но прежде чем добавлять файл в индекс, сделаем кое что другое, добавим в корне проекта файл .gitignore:

~/Projects/front-end-pro/.gitignore
```
# Web Storm directory
/.idea

# Visual Studio directory
/.vs

# Директория с модулями nodejs
/node_modules
```
.gitignore - файл с указаниями какие файлы и директории не должны попасть в индекс GIT. Например рабочие файлы IDE для нашего проекта, смысла шарить их с другими разработчиками нет, поэтому игнорируем их.

Полный список директорий для Visual Studio для .gitignore можно найти вот тут: See https://github.com/github/gitignore/blob/main/VisualStudio.gitignore

Все теперь можно добавлять наш файл в индекс гита, делается это с помощью команды:
```
git add .
```
Данная команда добавляет все файлы проекта в индекс (кроме тех которые указаны в .gitignore). т.е. мы как будто говорим: 'Гит, добавь в индекс все изменения которые произошли в нашем проекте!'.

Обратите внимание точка означает 'добавь в индекс все файлы которые были изменены'. Точку проще написать чем перечислять названия всех файлов через пробел, будем ее использовать всегда.

Если нужно добавить в индекс прицельно один или несколько файлов, перечисленных через пробел, то можно написать вот так тогда в файле .gitignore нет необходимости:
```
git add README.md
```

Посмотрим какое теперь состояние у нашего репозитория:
```
git status
```
Все, наш файл зелененький - теперь он в индексе.

Зафиксируем изменения:
```
git commit -m "Initial commit"
```
Данная команда создает новый коммит - снимок изменений нашего проекта. Это как комар в янтаре. Вы не можете с ним ничего сделать но можете на него посмотреть с разных сторон и сравнить с другим комаром например :)

Все, посылочка сформирована, давайте посмотри на нее повнимательнее:
```
git log
```
Данная команда показывает историю коммитов (снимков изменений). Здесь есть дата когда были сделаны изменения, имя и почта автора чтоб можно было потом найти и заставить съесть этого комара в случае чего :). И самое важное это уникальный идентификатор коммита который нельзя поменять. Он нужен что бы ваш коммит не потерялся среди других коммитов т.е. снимков изменений т.е. комаров.

Не подумайте что я бывший энтомолог, нет, по моему просто пример хороший.

(!) Тут важно отметить что когда вы создаете первый коммит в проекте то гит автоматически создает для вас новую ветку которая называется master или main, сейчас рекомендуется использовать название main для основной ветки по причинам связанным с историей рабства.

**Ветка (branch) в гите** - это последовательность коммитов. Мы поработаем с ними чуть позже.




## Отправим наши изменения:

Сейчас все наши изменения (коммиты) хранятся только локально и чтобы они стали доступны другим разработчикам мы должны отправить их на удаленный репозиторий откуда другие разработчики смогут их себе скачать. Выполним:
```
git push
```
Это команда отправляет наши изменения на удаленный репозиторий. Но первый раз она не сработает потому что мы не указали адрес куда отправлять коммиты, оно и не странно потому что адреса пока нет.

Создадим новый чистый репозиторий с названием таким-же как и директория проекта в https://github.com/new и скопируем новый адрес.

Теперь мы можем привязать локальный проект к удаленному репозиторию:
```
git remote add origin git@github.com:volodymyr-kryvoshapov/front-end-pro.git
```

Выполним снова команду
```
git push
```
И мы видим что гит все еще ничего не отправил а выдал нам новое сообщение:
```
fatal: The current branch main has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin main
```
Перевожу на язык понятный для простых смертных: да, я теперь знаю адрес репозитория куда отправлять изменения, и я вижу что ты свои изменения хранишь в локальной ветке main но я не в курсе в какую удаленную ветку ты хочешь отправить новые изменения. Может быть создать на удаленном сервере ветку с таким же названием как и на локальном сервере и отправить изменения в нее? Мы говори да, сделай это и выполняем команду которую предлагает гит.
```
git push --set-upstream origin main
```
Гит говорит нам что локальная ветка 'main' настроена на отслеживание удаленной ветки 'main' из 'origin' (удаленного репозитория). Настройка связи между локальной и удаленной ветками делается один раз для каждой ветки при попытке пуша.

Чтобы не преуменьшить скажу что названия локальных и удаленных веток совпадает в 110% случаев поэтому чтобы не писать каждый раз 'git push --set-upstream origin branch_name' а сразу работал 'git push' добавим конфиг:
```
git config --global branch.autosetupmerge always
```
Чтоб вернуть все в зад:
```
git config --global --unset branch.autosetupmerge
git config --list
```
Переходим на наш репозиторий в гитхабе, обновляем страницу и видим нашу ветку, наш коммит и наш файл.




## Исправим ошибку в коде (bug fix)

Итак, мы добавили первый файл, закомитили его и отправили на удаленный сервер чтоб он стал доступный всем. Но в этом файле есть ошибка, давайте исправим ее.

Не важно исправляем мы баг или делаем новую фичу, все изменения делаются в отдельных ветках. Отдельная ветка - это ответвление от другой ветки, в данном случае от ветки master. Аналогия с ветками деревьев очень удачная.

Чтобы создать новую ветку пишем команду:
```
git branch fix-readme-typo
```
Далее проверим что ветка создалась с помощью команды:
```
git branch
```
Ветка создалась но гит нам подсвечивает зеленым что мы сейчас находимся на ветки main. Но так как мы будем делать фикс в новой ветке то давайте переключимся на новую с помощью команды:
```
git checkout fix-readme-typo
```
Гит нам сообщает что переключение состоялось, давайте посмотрим еще раз:
```
git branch
```
Да, все в порядке.

Делаем фиксы в файле:
~/Projects/front-end-pro/README.md
```
Front End Pro home works
```
Перед коммитом можно проверить какие изменения были сделаны:
```
git diff
```
Это очень мощная команда которая позволяет сравнить два файла и показать отличия в них, что было добавлено, а что удалено.

Проверим состояние нашей ветки:
```
git status
```
Мы видим что несмотря на то мы уже добавляли этот файл в индекс это нужно делать каждый раз. Добавим:
```
git add .
```
Закоммитим изменения:
```
git commit -m "Fix typo in readme"
```
(!) Обращаю внимание на осмысленность сообщения в коммите, оно должно содержать короткое описание того что вы сделали.

Посмотрим теперь на историю коммитов:
```
git log
```
Мы видим что в нашей ветке fix-readme-typo добавился второй коммит. Но в ветке main коммитов по прежнему всего один. Чтобы наши изменения попали в ветку main переключимся на нее:
```
git checkout main
```
Убедимся что в ветке main всего один коммит:
```
git log
```
Теперь я хочу взять изменения из ветки с фиксом баги и добавить их в основную ветку. Для этого выполним:
```
git merge fix-readme-typo
```
Проверим что изменения добавились:
```
git log
```
Мы видим что коммитов теперь 3. Потому что при мердже создается новый коммит который содержит совмещенный код из того что было в ветке main + новые изменения. Отлично теперь отправим наши изменения на удаленный сервер:
```
git push
```
Все теперь наши изменения на удаленном сервере, давайте теперь посмотрим на них перейдя в https://github.com/volodymyr-kryvoshapov/front-end-pro

Вот что мы сделали (смотрим первый сиреневый круг):
<img src="./git-branch.png" width="700">




## Реализуем новую фичу 'calc' + Pull Request (PR):

Вместо двух команд: `git branch calc` а потом `git checkout calc` мы будем использовать совмещенную записью, которая создает ветку и сразу переключается на нее:
```
git checkout -b "calc"
```
Реализуем фичу, добавим два файла с кодом:

~/Projects/front-end-pro/calc/index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script src="index.js" async></script>
</head>
<body>
  <h1>Описание будет добавлено позже!</h1>
</body>
</html>
```
~/Projects/front-end-pro/calc/index.js
```html
console.log(calc(8, 9));


function calc(num, num2) {
  return num + num2;
}
```
Добавим изменения в индекс:
```
git add .
```
Закоммитим:
```
git commit -m "Calculator feature"
```
Отлично, закомитили.

А теперь не будем переключатся в `main` и затягивать `calc` в `main`, а сделаем кое-что интересное, мы добавим промежуточное действие pull request.

Pull request (PR) - это запрос разрешения на добавление изменений в какую-то ветку. Создавая PR вы говорите другим о намерении добавить изменения в какую-то ветку, и другие разработчикам теперь могут проверить ваш код на наличие ошибок, обсудить их, и если все ок, затянуть изменения в указанную ветку. Т.е. это промежуточный этап между переключением на ветку и затягиванием (мерджем) изменений из другой ветки.

PR используется в open-source проектах и компаниях для проверки качества кода (code review) перед тем как эти изменения будут 'затянуты' (именно поэтому и пулл реквест) в основную ветку. Под 'затянуть изменения' имеется ввиду мердж изменений `git merge branch_name`.

PR это фича не GIT а площадок которые работают на основе GIT. В GIT нет такой
команды как pull request.

Для этого запушим нашу ветку в удаленный репозиторий:
```
git push
```
Перейдем в Git Hub, создадим PR и отправим его на ревью:

Наш PR не прошел ревью, исправим его, добавим аннотацию для функции:

```javascript
console.log(calc(8, 9));

/**
 * Function adds two numbers
 *
 * @param {number} num
 * @param {number} num2
 * @returns {number}
 */
function calc(num, num2) {
  return num + num2;
}
```
Добавим изменения в индекс:
```
git add .
```
Закоммитим:
```
git commit -m "Added calc() f. description"
```
(!) Обратите что в сообщении для коммита мы пишем то что сделали.

Закомитили, теперь снова пушим в удаленный репозиторий:
```
git push
```
Снова скидываем ссылку на ревью. Другие разработчики подтверждают что теперь все ок.

И теперь мы мерджим изменения в `main` через интерфейс GitHub. Давайте посмотрим что изменения из нашей ветки действительно попали в `main`, перейдем на https://github.com/volodymyr-kryvoshapov/front-end-pro. Да действительно теперь наша фича `calc` в ветке `main`.

Вот что мы сделали (смотрим второй сиреневый круг):
<img src="./git-branch.png" width="700">

Следите за руками:
- Есть моя ветка в которой я запилил фичу и главная ветка `main` (`master`).
- Я хочу чтоб мои изменения из `calc` попали (затянули, были смерджены) в `main`.
- Я создаю запрос на добавление изменений (PULL Request) из `calc` -> `main`.
- Скидываю ссылку на PR другим разработчикам для проверки.
- Другие разработчики смотрят PR, этот процесс называется code review,
  отписывают комментарии если нужно что-то исправить.
- После исправлений делается новый `git commit` и `git push`.
- Код проверяется другими разработчиками снова и если все ок дается добро на мердж PR.
- PR мерджится в main.
- Ветка фичи `calc` более не нужна и может быть удалена.

Давайте удалим ее. Так как мы на ветке `calc` то переключимся в `main` потому что мы не можем удалить ту ветку на которой находимся:
```
git checkout main
```
Посмотрим на ветки перед удалением:
```
git branch
```
Удалим ветку `calc`
```
git branch -d calc
```
Посмотрим на ветки еще раз:
```
git branch
```
Отлично ветки больше нет. Удалять ветки не обязательно просто когда их станивится много то среди большого списка сложно найти свои актуальные ветки.




## Реализуем вторую фичу 'words-count' + PR:

Чтобы создать вторую фичу нам нужно создать новую ветку на основе `main` но мы не можем сейчас этого сделать т.к. локальная ветка `main` отличается от `main` на удаленном сервере. Потому что PR был смерджен на удаленном сервере и локальная ветка об этом пока ничего не занет. Убедимся в этом выполнив:
```
git log
```
Мы видим что локально только 3 комита, а должно быть 6. Затяним изменения из удаленного сервера в локальную ветку, для этого выполним:
```
git pull
```
Данная команда скачивает изменения в текущей ветке и меняет локальные файлы.

Все теперь ветка `main` актуальна и мы можем на ее основе создать ветку для новой фичи:
```
git checkout -b "words-count"
```
Создаем ветку на основе main (master) и сразу переключаемся на нее.

Добавим файлы с кодом:

~/Projects/front-end-pro/words-count/index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script src="./index.js" async></script>
</head>
<body>
<h1>Добавить описание сюда</h1>
</body>
</html>
```
~/Projects/front-end-pro/words-count/index.js
```html
console.log(wordsCount('Hello World!'));


/**
* Count number of words in sentence
*
* @param {string} str
* @returns {number}
*/
function wordsCount(str) {
  return str.split(' ').length;
}
```
Добавим изменения в индекс:
```
git add .
```
Закоммитим:
```
git commit -m "Words Counter feature"
```
Пушим в удаленный репозиторий:
```
git push
```
Теперь:
 - Создаем PR в GIT
 - Скидываем ссылку на ревью
 - Мерджим после успешного прохождения
 - Локально переключаемся в main и подтягиваем последние изменения
 - Ветку удалять не будем в этот раз




## Разрешение конфликтов в файлах:
Над проектом обычно работает много людей и когда два разработчика вносят изменения в одну и туже строку в одном и том же файле то при попытке мерджа изменений возникает конфликтная ситуация. GIT сообщает что не понимает изменения из какой ветки в итоге должны быть в этой строке. Конфликтные ситуации очень удобно разрешать с помошью IDE но мы ведь не ищем простых путей, поэтому покажу как это делается через консоль.

1. Представим что наш коллега внес изменения в два файла, смерджил их в ветку `main` и запушил их в удаленный репозиторий. Теперь они доступны другим разработчикам.

Вот что он сделал:

~/Projects/front-end-pro/calc/index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script src="index.js" async></script>
</head>
<body>
  <h1>Calculator</h1>
</body>
</html>
```

~/Projects/front-end-pro/words-count/index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script src="index.js" async></script>
</head>
<body>
  <h1>Words count</h1>
</body>
</html>
```

~/Projects/front-end-pro/README.md
```
Домашние работы по курсу Front End Pro
```
Замечу, его изменения уже находятся на удаленном сервере.


Мы тоже решили поправить эти файлы, и внесли локально свои изменения:

~/Projects/front-end-pro/calc/index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script src="index.js" async></script>
</head>
<body>
  <h1>Калькулятор</h1>
</body>
</html>
```

~/Projects/front-end-pro/words-count/index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script src="index.js" async></script>
</head>
<body>
  <h1>Подсчет слов в предложении</h1>
</body>
</html>
```

~/Projects/front-end-pro/README.md
```
Front End Pro домашки
```
Чтоб пример был более понятный я не стал создавать отдельную ветку для фикса.

Сохраняем изменения:
```
git commit -m 'Updated readme and calc header descriptions'
```
Теперь у нас есть проблема потому что я и мой коллега поправили одни и те же строки в одних и тех же файлах.

Далее, я понимаю что за время моего фикса ветка `main` уже могла изменится, и я ожидаю что могут быть конфликты, поэтому, прежде чем отправить мои изменения, в первую очередь, я всегда забираю последние изменения из мастера. Чтобы убедится что нужно что-то забрать из мастера я делаю:
```
git fetch origin
```
Эта команда скачать инфу о новых ветках и их изменениях с удаленного сервера, но при этом НЕ меняет локальные файлы.

Далее мы пишем:
```
git status
```
И теперь гит статус обладая новой инфой подсказывает нам что моя локальная ветка и удаленная отличается на несколько коммитов и что перед отправкой моих изменений мне нужно забрать актуальные с сервера и сделать `gut pull` но я напишу немного другое:
```
git merge origin/master
```
Если бы я написал сразу `git pull` то `git fetch` и `git merge` произошли бы неявно для нас, и мы бы сразу попали в ситуацию разрешения конфликта, поэтому для наглядности я использовал две команды вместо одной.

Далее начинается разрешение конфликта. Посмотрим что происходит введя:
```
git status
```
Мы видим надпись `both modified` она означает что файлы локальные и на удаленном сервере содержит конфликт который нужно решить.

Далее пример который я покажу может немножко напугать, так как вы с этим еще не сталкивались, но в этом нет ничего страшного. Мы открываем файл в редакторе и видим вот что:

~/Projects/front-end-pro/README.md
```
<<<<<<< HEAD
Front End Pro домашние работы
=======
Front End Pro home words
>>>>>>> origin/master
```
Тут Гит говорит нам: 'я обнаружил изменения в одинаковой строке, выбери то которое хочешь оставить'. То которое между HEAD и знаками равно это локальные изменения, а то что между знаками равно и origin/master это изменение с сервера.

Мы выбираем то что хотим оставить у удаляем все лишние символы. В итоге у нас должно получится:

~/Projects/front-end-pro/README.md
```
Front End Pro домашние работы
```
Далее редактируем остальные файлы таким же образом и добавляем изменения в индекс:
```
git add .
```
Cохраняем изменения
```
git commit -m 'fix merge conflicts'
```
Отправляем изменения в удаленный репозиторий:
```
git push
```
Переходим чтоб проверить: https://github.com/volodymyr-kryvoshapov

Смотрим нашу ветку main и видим наши изменения. В readme добавились изменения коллеги, а в два других файла мои изменения. Так и проходит процесс решения конфликтов.

Конфликты случаются не так уж и редко поэтому нужно уметь с ними работать. Процесс разрешения конфликтов максимально упрощает использование IDE.




## Удобные команды:
Клонировать удаленный репозиторий:
```
git clone
```
Эта команда нужна чтоб скопировать удаленный репозиторий себе локально и сразу начать работать с новым проектом. Например что бы исправить багу в публичном проекте. Или когда вы приходите на новую работу то как правило вы не начинаете новый проект с нуля, а запускаете уже существующий, для этого вам дают адрес с которого вы и скачиваете его себе.

Давайте склоним себе проект по переименованию файлов
```
git clone git@github.com:volodymyr-kryvoshapov/copy-replace.git
```
Теперь проект скопирован локально и можно посмотреть какие-то детали или написать новую фичу или исправить ошибку и создать PR чтобы владелец проекта посмотрел на то что вы собираетесь добавить и добавил эти изменения или отклонил.

У этой команды есть и второй способ использования, если локально проект у вас еще не существует то гораздо быстрее будет создать его на Git Hub потом склонировать локально и можно сразу начинать работать. Причем на Git Hub при срздании проекта можно сразу  выбрать добавить README.md файл и .gitignore указав IDE с которой вы работаете.

Создадим проект на Git Hub и склоним его себе:
```
git clone git@github.com:volodymyr-kryvoshapov/cool-project.git
```

Команда обновить локальную информацию об удаленном репозитории.
```
git fetch --all
```
Эта команда скачивает информацию о новых ветках и их изменениях с удаленного сервера, но при этом НЕ меняет локальные файлы в отличии от `git pull` которая как-раз их меняет.
Эта команда нужна например чтоб переключится на какую-то ветку которая есть на удаленном репозитории, а локальный проект про эту ветку ничего не знает, потому что  давно не обновлялся. Для этого нужно сперва выполнить `git fetch --all` который обновит локально информацию об всех удаленных ветках а уже потом `git checkout branch-name`


Отменить один или несколько коммитов. Создает новый коммит с отмененными изменениями.
```
git revert commit_hash
```
Представьте себе ситуацию, что вам поступила задача от менеджера, вы ее сделали, закомитили, и отправили на удаленный сервер. А потом приходит менеджер и говорит, случай обстоятельства поменялась, отмени изменения, и вместо того чтоб вручную возвращать каждому файлу прежний вид вы используете это команду.

Например у нас сейчас вот такие коммиты:
```
git log --oneline

cb76ee4 wrong
01b56c6 test
2e407ce first commit
```
Пишем:
```
git revert cb76ee4
```
Эта команда отменить ваши изменения из коммита cb76ee4 и вернет ваши файлы обратно к 01b56c6 и добавит новый коммит в историю:
```
git log --oneline

8d4406b Revert "wrong"
cb76ee4 wrong
01b56c6 test
2e407ce first commit
```

Если вы хотите именно что удалить несколько коммитов то это можно сделать с помощью команды:
```
git reset --soft HEAD~2 
```
Данная команда удалить 2 последних коммита из истории но изменения не пропадут, а добавятся обратно в индекс таким образом вы не потеряете изменения из двух коммитов, они станут как-бы не закоммичеными и вы сможете их снова закомитить. Если написать
```
git reset --hard HEAD~2 
``` 
То 2 коммита + изменения из них будут удалены безвозвратно и файлы вернутся к состоянию
```
git log --oneline

01b56c6 test
2e407ce first commit
```

Сохранить незакомиченные изменения и очистить и привести файлы в состояние последнего актуального коммита:
```
git stash
``` 
Это удобно когда вы что-то делаете, не закончили и не хотите пока коммитить изменения и вы как бы сохраняете ваши изменения в буффер, и например переключаетесь на другую ветку что-то делаете там, потом возвращаетесь на прежнюю ветку, и достаете из буыера свои изменения:
```
git stash pop
```
Вы достали свои изменения из буфера и можете продолжать работать.



Памятка удобных команд:
- git checkout 'branch-name' - переключится на ветку.
- git checkout -b "fix-readme-typo" создать ветку + переключится на нее.
- git branch - отобразить список веток в репозитории
- git branch -r покажи все ветки в удаленном репозитории
- git branch -a покажи все локальные + ветки в удаленном репозитории
- git branch branch-name - создание новой ветки без переключения на нее
- git branch -d branch-name безопасное удаление, если ветка не отправлена на удаленный репозиторий то она не будет удалена.
- git branch -D branch-name принудительное удаление, удалит в любом случае.
